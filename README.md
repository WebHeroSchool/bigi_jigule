# JavaScript Best Practices by Nadir Begiyev :)__

### 1. Использовать строгое сравнение.
+ #### Операторы нестрогого равенства/неравенства (`==` или `!=`) будут приводить значения к одному типу перед сравнением. При использовании же операторов строгого равенства/неравенства (`===` или `!==`) сравнение производится не только по значениям, но и по типам сравниваемых данных
```
  0 == "";        // true
  1 == "1";       // true
  1 == true;      // true

  0 === "";       // false
  1 === "1";      // false
  1 === true;     // false
```

---

### 2. Объявляйте переменные в самом начале.

+ #### Что же это дает? 
 + #### 1. Более чистый код.
 + #### 2. Локальные переменные находятся в одном месте и их легко найти.
 + #### 3. Легче избегать нежелательных глобальных переменных.
 + #### 4. Снижается вероятность повторного объявления переменных. 
 
 ---
 
 ### 3. Размещайте скрипт в конце страницы.

 + #### Чем выше вы расположите скрипт, тем раньше он начнет выполняться. Это грозит блокировкой основного контента. Поэтому лучше располагайте большинство скриптов в самом конце (перед </body>). Скорость отображения контента имеет большое значение. Далеко не все клиенты и читатели готовы ждать несколько секунд до появления основной информации.
 
 ---

### 4. Воздействовать на классы DOM-елементов, а не их инлайн-стили.
+ #### Если нужно сделать отдельные элементы страницы интерактивными, то правильнее будет воздействовать на список классов этих элементов, чем напрямую обращаться к их стилям. Данный подход позволяет:

+ #### Создать несколько паттернов (.css-классов) и однообразно воздействовать на разные DOM-элементы;
+ #### Быстрее редактировать/отлаживать необходимые параметры, тк они находятся в одном месте и не дублируются в JS-коде;
+ #### Снизить вероятность "сломать" всю вёрстку из-за разной приоритетности стилей;
+ #### Сократить количество кода и повысить его читабельность.
+ #### Как пример - визуализация валидации пустой строки ввода текста (Граница должна стать красного цвета):

**Bad practice**

```
  const f = document.getElementById('mainform');
  const inputs = f.getElementsByTagName('input');
  for (let i = 0, j = inputs.length; i < j; i++){
    if (inputs[i].className === 'mandatory' && inputs.value === ''){
        inputs[i].style.borderColor = '#f00';
        inputs[i].style.borderStyle = 'solid';
        inputs[i].style.borderWidth = '1px';
    }
  }
```

**Good practice**

CSS:
```
  .error {
    border: 1px solid red;
  }
```

  JS:
```
  const f = document.getElementById('mainform');
  const inputs = f.getElementsByTagName('input');
  for (let i = 0, j = inputs.length; i < j; i++){
    if (inputs[i].className === 'mandatory' && inputs.value === ''){
        inputs[i].classList.add('error');
    }
  }
```

---
  
  ### 5. Массивы
  + #### Для создания массива используйте литеральную нотацию. eslint: `no-array-constructor`
  ```
  // плохо
  const items = new Array();

  // хорошо
  const items = [];
  Для добавления элемента в массив используйте Array#push вместо прямого присваивания.
  const someStack = [];

  // плохо
  someStack[someStack.length] = 'abracadabra';

  // хорошо
  someStack.push('abracadabra');
  Для копирования массивов используйте оператор расширения ... .
  // плохо
  const len = items.length;
  const itemsCopy = [];
  let i;

  for (i = 0; i < len; i += 1) {
    itemsCopy[i] = items[i];
  }

  // хорошо
  const itemsCopy = [...items];
  ```
  
  ---
  
  ## 6. Функции
 + #### Используйте функциональные выражения вместо объявлений функций. eslint: `func-style`
  + #### Почему? У объявлений функций есть подъём. Это означает, что можно использовать функцию до того, как она определена в файле, но это вредит читабельности и поддержке. Если вы обнаружили, что определение функции настолько большое или сложное, что мешает понимать остальную часть файла, то, возможно, пришло время извлечь его в отдельный модуль. Не забудьте явно назвать функциональное выражение, независимо от того, подразумевается ли имя из содержащейся переменной (такое часто бывает в современных браузерах или при использовании компиляторов, таких как Babel). Это помогает точнее определять место ошибки по стеку вызовов. (Обсуждение)

```
  // плохо
  function foo() {
    // ...
  }

  // плохо
  const foo = function () {
    // ...
  };

  // хорошо
  // лексическое имя, отличное от вызываемой(-ых) переменной(-ых)
  const foo = function uniqueMoreDescriptiveLexicalFoo() {
    // ...
  };
```
  + #### Оборачивайте в скобки немедленно вызываемые функции. eslint: `wrap-iife`
  + #### Почему? Немедленно вызываемая функция представляет собой единый блок. Чтобы чётко показать это — оберните функцию и вызывающие скобки в ещё одни скобки. Обратите внимание, что в мире с модулями вам больше не нужны немедленно вызываемые функции.

**// Немедленно вызываемая функция:**
```
  (function () {
    console.log('Welcome to the Internet. Please follow me.');
  }());
```
  Никогда не объявляйте функции в нефункциональном блоке (`if`, `while`, и т.д.). Вместо этого присвойте функцию переменной. Браузеры позволяют выполнить ваш код, но все они интерпретируют его по-разному. eslint: `no-loop-func`

---

### 7. Стрелочные функции
+ #### Когда вам необходимо использовать анонимную функцию (например, при передаче встроенной функции обратного вызова), используйте стрелочную функцию. eslint: `prefer-arrow-callback, arrow-spacing`
> Почему? Таким образом создаётся функция, которая выполняется в контексте this, который мы обычно хотим, а также это более короткий синтаксис.

> Почему бы и нет? Если у вас есть довольно сложная функция, вы можете переместить эту логику внутрь её собственного именованного функционального выражения.
```
// плохо
[1, 2, 3].map(function (x) {
  const y = x + 1;
  return x * y;
});

// хорошо
[1, 2, 3].map((x) => {
  const y = x + 1;
  return x * y;
});
```
+ #### Если тело функции состоит из одного оператора, возвращающего выражение без побочных эффектов, то опустите фигурные скобки и используйте неявное возвращение. В противном случае, сохраните фигурные скобки и используйте оператор return. eslint: `arrow-parens, arrow-body-style`
> Почему? Синтаксический сахар. Когда несколько функций соединены вместе, то это лучше читается.
```
// плохо
[1, 2, 3].map((number) => {
  const nextNumber = number + 1;
  `A string containing the ${nextNumber}.`;
});

// хорошо
[1, 2, 3].map((number) => `A string containing the ${number + 1}.`);

// хорошо
[1, 2, 3].map((number) => {
  const nextNumber = number + 1;
  return `A string containing the ${nextNumber}.`;
});
```

---

### 8. Свойства
+ #### Используйте точечную нотацию для доступа к свойствам. eslint: `dot-notation`
```
const luke = {
  jedi: true,
  age: 28,
};

// плохо
const isJedi = luke['jedi'];

// хорошо
const isJedi = luke.jedi;
Используйте скобочную нотацию [], когда название свойства хранится в переменной.
const luke = {
  jedi: true,
  age: 28,
};

function getProp(prop) {
  return luke[prop];
}

const isJedi = getProp('jedi');
Используйте оператор ** для возведения в степень. eslint: no-restricted-properties.
// плохо
const binary = Math.pow(2, 10);

// хорошо
const binary = 2 ** 10;
```

---

### 9. Переменные
+ ####Всегда используйте const или let для объявления переменных. Невыполнение этого требования приведёт к появлению глобальных переменных. Необходимо избегать загрязнения глобального пространства имён. eslint: `no-undef prefer-const`
```
// плохо
superPower = new SuperPower();

// хорошо
const superPower = new SuperPower();
```
+ ####Используйте объявление const или let для каждой переменной или присвоения. eslint: `one-var`
>Почему? Таким образом проще добавить новые переменные. Также вы никогда не будете беспокоиться о перемещении ; и , и об отображении изменений в пунктуации. Вы также можете пройтись по каждому объявлению с помощью отладчика, вместо того, чтобы прыгать через все сразу.

+ #### В первую очередь группируйте const, а затем `let`.
>Почему? Это полезно, когда в будущем вам понадобится создать переменную, зависимую от предыдущих.

---

### 10. Комментируйте столько, сколько необходимо, но не больше. 

+ #### Комментарии - это своборазные сообщения разработчикам и самому себе, чтобы понимать и учитывать все особенности кода. Комментируйте только тогда, когда нужно сказать что-то важное. Для однострочных комментариев используются // (хотя они и менее универсальны), для многострочных /* */. Также комментарии могут быть использованы, чтобы "спрятять" неиспользуемый код. Однако, оставлять закомментированный код в рабочих версиях продукта - это плохая практика. Его необходимо удалить. А если вдруг старый код вам понадобится, то его лучше искать в старых версиях кода.
